\documentclass[../../main.tex]{subfiles}
\begin{document}
	\tableofcontents
	\newpage
	\section{Introduction}
		Oldschool Runescape is a MMORPG which features combat. In combat, players are awarded experience for damage dealt to their opponents (often called monsters). After a certain amount of experience is gained the player may level up, improving the abilities in combat. The mechanics of combat involve accuracy, maximum damage, attack speed, among other details. There have been several attempts to quantify the experience rates according to a player's, and their opponent's levels and equipment. Although they are quite accurate, there are additional corrections that can be applied. Additionally extensions to more complex fighting scenarios has not been performed. We will be specifically considering applications to the Nightmare Zone, a common method of training combat. This game is played with long term investments and considerations in mind, as many achievements are achieved over periods of months or even years. In this sense, even minor optimizations can result in real-world savings for the player. Furthermore, a codebase accompanies this article which allows for more advanced use of the derived formulas (such as in optimization problems). These are the central motivations for this study (and its fun!).

	\section{Damage}
		The \href{https://oldschool.runescape.wiki/w/Maximum_hit}{official Wiki page} provides a very good review of maximum hit mechanics. For completion we will provide a brief summary. For some reason, it does not contain information about accuracy calculations. These are can be found (unofficially) from \href{https://www.osrsbox.com/blog/2019/01/22/calculating-melee-dps-in-osrs/}{osrsbox} (which references \href{https://docs.google.com/spreadsheets/d/1wzy1VxNWEAAc0FQyDAdpiFggAfn5U6RGPp2CisAHZW8/edit#gid=158500257}{DPS calculator by Bitterkoekje}, the \href{https://web.archive.org/web/20190905124128/http://webcache.googleusercontent.com/search?q=cache:http://services.runescape.com/m=forum/forums.ws?317,318,712,65587452}{forum post} of which has been archived), \href{https://www.reddit.com/r/2007scape/comments/40bvk6/accuracy_and_exphr_combat_formula/}{MachOSRS} (reddit), and \href{https://www.reddit.com/r/2007scape/comments/5lrty0/math_inside_corrected_accuracy_formula/}{[deleted]} (reddit).  Following this, we will take care to accurately determine the number of hits required to kill an opponent, followed by experience rate calculations. Related calculations have been performed by \href{https://www.reddit.com/r/2007scape/comments/4d6l7j/effects_of_overkill_on_dps/}{Nukelawe}, which discusses the impact of overkill on expected damage, which is often neglected in damage calculations. However we will justify that the application of this formula is not properly accounted for and we will instead provide an more accurate method.
		\subsection{Maximum Hit}
			There are three combat styles in the game: Melee, ranged, and magic. The former two are quite similar, while the latter is slightly more involved. We will let $m$ will denote the player's maximum hit (for whatever combat style). In general, there are 5 bonuses that a player can obtain to boost their maximum hit. These are bonuses from: potions, prayer, other, style, and special attack. These will be referred to as: $B^\text{pot}$, $B^\text{pray}$, $B^\text{other}$, $B^\text{style}$, $B^\text{SA}$, respectively. For non-magic styles, an effective damage level is defined as
			\begin{align}
				L^\text{eff} \equiv \left \lfloor \left(L + B^\text{pot} \right)B^\text{pray}B^\text{other} \right \rfloor + B^\text{style},
			\end{align}
			where $L$ is either the ranged level or strength level. The base damage, $D^\text{base}$ is then given by,
			\begin{align}
				D^\text{base} = C_0 + C_1S^\text{eff} + C_2 E^\text{str} + C_3 E^\text{str}S^\text{eff},\\
				\text{where}\,\,\, \{C\} = \left\{1.3, \frac{1}{10}, \frac{1}{80}, \frac{1}{640}\right\},
			\end{align}
			and $E^\text{str}$ is the ranged or melee strength bonus of the worn equipment. The max hit, $M$ is then given by,
			\begin{align}
				\boxed{M = \left \lfloor D^\text{base} B^\text{SA}\right \rfloor,}
			\end{align}
			where $B^\text{SA} = 1$ if no special attack is being used.

 			For melee, the \texttt{Keras} and \texttt{Saradomin Sword} are exceptions to this (see the wiki). For ranged, it should be noted that \texttt{bolt} effects only have probabilities of activating (and therefore increasing $M$). For future considerations, this could be handled by defining an effective or average max hit: $\langle M \rangle = P M$, where $P$ is the probability of activation. Additionally, some sources state that some equipment which would be categorized under ``other'' bonuses such as the \texttt{Slayer helmet} actually use $\left \lfloor D^\text{base} B^\text{SA}B^\text{other}\right \rfloor$ and so act as a multiplier instead of its expected placement. This is not stated on the wiki, but appears to be correct.
			\subsubsection{Magic}
				The base damage for a magic spell is given according to that spell. For magic, only multiplicative bonuses are obtainable. For a single bonus is given by,
				\begin{align}
					M = D^\text{base}E^\text{str},
				\end{align}
				where now $E^\text{str}$ is the multiplicative magic damage bonus (think ``magic strength''). In general, these effects stack, but intermediate flooring calculations can impact the max hit (again see the wiki). \texttt{Charge}, \texttt{Magic dart}, \texttt{Salamanders}, and \texttt{Trident of the seas/swamp} have alternate calculations.
		\subsection{Accuracy}
			$A$ will denote the player's probability of a successful hit (called accuracy). This attribute depends on both the player and the opponents stats. For all three combat styles, the attacker rolls an attack role, while the defender rolls a defensive roll. First effective levels are calculated,
			\begin{align}
				L^\text{eff}_A \equiv \left \lfloor \left(L + B^\text{pot} \right)B^\text{pray}B^\text{other} \right \rfloor + B^\text{style} + 8,
			\end{align}
			where the subscript on $L_A$ is used to denote the difference between the effective damage levels discussed above, and these effective accuracy levels.
			Then the maximum roll is given by,
			\begin{align}
				R_\text{max} = \left \lfloor L_A^\text{eff} (E + 64)\right \rfloor,
			\end{align}
			where $E$ is the equipment bonus for the respective attack or defense style.
			Now the accuracy is given according to,
			\begin{empheq}[box=\fbox]{align}
				A = \begin{cases}
					1 - \frac{1}{2}\frac{D_\text{max} + 2}{A_\text{max} + 1} & A_\text{max} \ge D_\text{max} \\
					\frac{A_\text{max}}{2D_\text{max} + 2} & \text{else},
				\end{cases}
			\end{empheq}
			where $A_\text{max}$ and $D_\text{max}$ represent the maximum attack and defense rolls ($R_\text{max}$) respectively. This is plotted in Fig.~\ref{fig:accuracy}. No information suggests magic accuracy is any different. No other work / official statements show how special attacks factor into this. It is a fair assumption that $A^\text{eff} = AB^\text{SA}$ for special attacks that increase accuracy (since no flooring needs to be done for accuracy).

		\subsection{Average Damage}\label{sec:average_damage}
			Here begins the new calculations (if the previous sections were unclear, please read the cited references). The damage done during an attack is uniformly distributed on $[0, M]$, so each integer between 0 and the max hit have an equal chance of $1/(M + 1)$ of occurring. The average damage done during an attack is the expectation,
			\begin{align}
				\langle D \rangle &= \frac{1}{M+1}\sum_{i=0}^{M} i\\
				&= \frac{1}{\cancel{M+1}}\frac{M(\cancel{M+1})}{2}\\
				&= \frac{M}{2}
			\end{align}
			However, this makes the assumption that the player can always hit up to their max hit. This is not the case if the opponent has less health, $h$ than the maximum hit. This effect is sometimes referred to as \textit{overkill} damage.
			\begin{center}
			\begin{tikzpicture}
				\filldraw[fill=green, draw=black] (0,0) node[anchor=north] {$0$} -- (4,0) node[anchor=north] {$h$} -- (4,0.5) -- (0,0.5) -- (0,0);
				\filldraw[fill=red, draw=black] (4,0) -- (6,0) node[anchor=north] {$M$} -- (6,0.5) -- (4,0.5) -- (4,0);
				\draw [decorate,decoration={brace,amplitude=10pt},xshift=0pt,yshift=15pt]
				(0,0) -- (4,0) node [black,midway,yshift=15pt]{
					\footnotesize $h+1$
				};
				\draw [decorate,decoration={brace,amplitude=10pt},xshift=0pt,yshift=15pt]
				(4,0) -- (6,0) node [black,midway,yshift=15pt]{
					\footnotesize $M-h$
				};
			\end{tikzpicture}
			\end{center}
			In this case, we could hit every integer below $h$ each with a probability of $1/(M+1)$, and we could hit exactly $h$ (since we're considering hits capped by $h$) with a probability of $(M-h)/(M+1)$. Averaging the expectations gives,
			\begin{align}
				\langle D \rangle_{h < M} &= \frac{1}{M+1}\sum_{i=0}^{h} i + \frac{M-h}{M+1}h \\
				&= \frac{1}{M+1}\frac{h(h+1)}{2} + \frac{M-h}{M+1}h \\
				&= \frac{h}{2}\frac{2M-h+1}{M+1}\\
				&= \frac{h}{2}\left(1 + \frac{M - h}{M+1}\right)\\
				&= \frac{h}{2}\left(2 - \frac{h + 1}{M+1}\right)
				% &= \frac{h^2}{2m} + \frac{h}{2m} + h - \frac{h^2}{m} \\
				% &= -\frac{h^2}{2m} + \left(\frac{1}{2m} + 1\right)h \\
			\end{align}

			Overall then, our expected damage on a successful hit is:
			\begin{align}
				\boxed{
					\langle D \rangle = \frac{1}{2}\begin{cases}
						M &\text{if $h \ge M$} \\
						h\left(2 - \frac{h + 1}{M+1}\right) &\text{if $h < M$} \\
					\end{cases}
				}
			\end{align}

			\begin{figure}
				\centering
				\begin{subfigure}{.45\textwidth}
					\centering
					\includegraphics[width=\linewidth]{img/Accuracy-crop.pdf}
					\caption{Player accuracy as a function of the player's maximum accuracy roll and opponent's maximum defense roll. The black line is the piecewise boundary.}
					\label{fig:accuracy}
				\end{subfigure}
				\begin{subfigure}{0.04\textwidth}\end{subfigure}
				\begin{subfigure}{.45\textwidth}
					\centering
					\includegraphics[width=\linewidth]{img/average_d-crop.pdf}
					\caption{The average damage of an attack with a maximum hit of $M$ on an opponent with $h$ health. The black line is the piecewise boundary.}
					\label{fig:average_d}
				\end{subfigure}
			\end{figure}


			This is plotted in Fig.~\ref{fig:average_d}. Nukelawe presents a formula for the \emph{overall} (i.e. not piecewise) expected hit, assuming each starting health is equally likely. We will justify that this isn't the correct approach for calculating turns to kill, or damage per second in the next section. Regardless, it is good to check that our equations agree:
			\begin{align}
				\langle D \rangle_\text{overall} &= \left \langle \langle D \rangle_{h < M} + \langle D\rangle_{h\ge M} \right \rangle\\
				&= \frac{1}{h_0}\left(\sum_{h<M} \langle D \rangle_{h < M} + \sum_{h\ge M}\langle D\rangle_{h\ge M} \rangle \right)\\
				&= \frac{1}{h_0}\left(
					\sum_{n=M+1}^{h_{0}}\frac{M}{2} +
					\sum_{n=1}^{y} \frac{n}{2}\left(2 - \frac{n + 1}{M+1}\right)
				\right) \\
				&= \frac{y(y+1)}{h_0(M+1)}\left(\frac{1}{2}{(M+h_0+1)}-\frac{1}{3}(2y+1) \right),
			\end{align}
			where $y=\min(M, h_0)$. The last step is actually quite tricky and involved to show. For that reason it can be found in the Appendix. This agrees with Nukelawe's findings.

		\subsection{Health after $n$ Attacks}
			Despite the above being an ``average'', it is not the average damage expected per hit over the life time of an opponent since certain healths are much more likely to appear than others. As an example, suppose there is an opponent with 100 health fighting an attacker with a max hit of 30. On the first hit, the most likely health is 85. This means that unlike the above calculation, each hit is \emph{not} equally likely. Particularly, this over estimates the contribution in the overkill region, since (depending on the circumstances) let's say 1 or 2 hits is expected per kill. Those 1 or 2 hits are more likely to occur at specific $h$ values, but the average sums across all $h$ equally. In the non-overkill region, this has no impact due to it being constant. So either a \href{https://en.wikipedia.org/wiki/Markov_chain}{Markov-Chain} type analysis is required or the following: To determine the health of an opponent after a given number of \textit{successful} attacks (we can include accuracy later), we note that the piecewise damage expectation gives a recursive function for the health, $h_n$ of an opponent after $n$ attacks,
			\begin{align}
				h_{n+1} = h_{n} - \frac{1}{2}\begin{cases}
					m &\text{if $h_n \ge M$} \\
					h_n\left(2 - \frac{h_n + 1}{M+1}\right) &\text{if $h_n < M$}.
				\end{cases}
			\end{align}
			This however is too cumbersome to handle at once. Since the health is a decreasing monotonic function, we can consider it in two parts. While $h$ is above or equal to $M$ the solution to the above becomes,
			\begin{align}
				h_{n+1} &= h_{n} - \frac{M}{2} \\
				&\implies h_n = h_0 - n\frac{M}{2},\label{eq:h_crude}
			\end{align}
			where $h_0$ is the maximum / starting health. The solution to the other is a bit more complex. After a certain number of iterations the health will drop below $M$ and the second case above will kick in. We'll say this occurs after $L$ iterations (noting that this \emph{average} quantity can be a non-integer),
			\begin{align}
				M &> h_0 - L\frac{M}{2} \\
				\frac{2}{M}(h_0 - M) &< L \\
				\implies L &= 2\left(\frac{h_0}{M} - 1\right).
			\end{align}
			Now the expected health that the second condition starts at is given by,
			\begin{align}
				\langle h_L \rangle &= h_0 - 2\left(\frac{h_0}{M} - 1\right) \frac{M}{2}\\
				&= M.
			\end{align}
			Thus the second case is expected to starts on iteration $L$ with an initial health of $M$. For simplicity, we will define $m\equiv n-L$. Returning to our recursive function,
			\begin{align}
				h_{m+1} &= h_{m} - \frac{h_m}{2}\left(2 - \frac{h_m + 1}{M+1}\right) \\
				&= h_{m} - h_m + \frac{h_m}{2}\frac{h_m + 1}{M+1} \\
				&= \frac{h_m^2 + h_m}{2(M+1)} \\
				h_{m+1} &= \gamma (h_m^2 + h_m),\,\,\,h_0 = M, \label{eq:recur}
			\end{align}
			where $\gamma\equiv1 / 2(M+1)$. This type of recurrence relation is called a \href{http://mathworld.wolfram.com/QuadraticMap.html}{Quadratic Map}, and unfortunately it has no closed form solution in general. Some work is shown in the appendix to attempt to simplify it, but no final form was realized. For the sake of completeness, we will call the solution to Eq.~\ref{eq:recur} $f(M; f_0)$. At this point we're left with,
			\begin{align}
					h(n; h_0, M) &=  \begin{cases}
					h_0 - \frac{1}{2}nM &\text{else if $n \le L$} \\
					f(n - L; M) &\text{otherwise}.
				\end{cases}
			\end{align}
			In general, we are more interested in the number of iterations that is required to kill an opponent which is the inverse of this function, $n=h^{-1}(h; h_0, M)$. However, since the recurrence relation cannot be solved analytically, we cannot obtain a general expression for this. We could numerically compute this result. However remember that we are dealing with \emph{expectation values} or averages. This means it is totally possible for the inverted function to say ``The opponents health will be 18 in 4.5 iterations, on average''. This is a problem because our recursive equation can only increment the iteration by one (and we can only start at $f_0$)! In the next section, we will look at an approximation that will allow us to handle non-integer expectations.

		\subsubsection{Approximate Solutions}
			Despite not being able to find a closed-form solution for Eq.~\ref{eq:recur}, we can look for approximate solutions. Although it's rare, there are a few quadratic recurrence relations that \textbf{do} have solutions. There are two relevant cases, one where a constant term is introduced, or ones where the linear term is removed. Since increasing $n$ (and therefore iterations) results in smaller and smaller $h_n$, it suggests that adding constant terms will heavily skew the results in this region. Removing the linear term is still not ideal since its contribution increases relative to the quadratic term, in the low $h_n$ limit (when this recursive case is required). However this should be less significant and we'll find that it does pretty well! In this case, our recursive relation becomes,
			\begin{align}
				h_{m+1} = \gamma h_m^2.
			\end{align}
			Starting with $h_0 = M$, and looking at a few terms reveals,
			\begin{align}
				h_{1} &= \gamma^1 M^2\\
				h_{2} &= \gamma^1 h_1^2\\
					&= \gamma^1 \gamma^2 M^{(2\cdot2)}\\
				h_{3} &= \gamma^1 h_2^2\\
					&= \gamma^1 \gamma^2 \gamma^4 M^{(2\cdot2\cdot2)}\\
				\implies h_m &= \gamma^{\sum_{i=0}^{m-1} 2^i} M^{2^m}\\
							&= \gamma^{2^m-1} M^{2^m}\\
							&= \frac{1}{\gamma}(\gamma M)^{2^m}\\
						\Aboxed{h_m &= \frac{1}{\gamma}\left(\frac{1}{2} - \gamma\right)^{2^m}}
			\end{align}
			This equation is not only a closed form expression, but it can also be inverted!
			\begin{align}
				\log_2(\log_{\frac{1}{2} - \gamma} (\gamma h_m)) &= m.
			\end{align}
			This equation asymptotically reaches 0, but the opponent dying occurs when $h_m$ drops below 1 yielding an average kill on iteration,
			\begin{align}
				\log_2(\log_{\frac{1}{2} - \gamma} (\gamma)) &= m.
			\end{align}

			How can we make use of this approximation to improve our more accurate calculation? Remember that we are trying to solve the issue of non-integer iterations. Instead of beginning on iteration 0 for the iterative procedure, we can start $m$ at any real number in (0, 1), and iterate upwards on that. For example to get the health at iteration 4.87, we could use our analytic approximation to calculate 0.87 (which uses \textit{one} approximation), then iterate 4 times using the correct equation to get to the final result. So this defines our new best approximation,
			\begin{empheq}[box=\fbox]{align}\label{eq:recursive_h}
					h(n; h_0, M) &=  \begin{cases}
					h_0 - \frac{1}{2}nM &\text{if $n \le L$} \\
					\frac{1}{\gamma}\left(\frac{1}{2} - \gamma\right)^{2^{n-L}} &\text{if $n - L < 1$}\\
					f\left(n - L; \frac{1}{\gamma}\left(\frac{1}{2} - \gamma\right)^{2^{n-L}}\right) &\text{otherwise}\\
				\end{cases}\\
				\text{where, }\gamma = &\frac{1}{2(M+1)}\text{ and } L = 2\left(\frac{h_0}{M} - 1\right).\nonumber
			\end{empheq}
			To solve for when the opponents health drops below one, $n=h^{-1}(1)$, we must use a numerical root finding algorithm to solve for the zero of $(1 - h(n))$. It is possible that $h^{-1}(1/2)$ is more representative of death than $h^{-1}(1)$. This should be discussed.


			\subsubsection{Comparisons}
				We have seen several methods for calculating expected kill iterations. We can now compare these models to numerically simulated fights as in Fig.~(\ref{fig:comparison}). Regardless of the model, the turns to kill grows quickly when the max hit is low compared to the initial health of the opponent (as expected). The models deviate the most from the simulations when the initial health is low, and when the max hit is high. Both the crude method and the Bitt-Nuke method are have unbounded errors, while the Recursive method actually has a maximum near $(h, M) \approx (25, 80)$. Thus the recursive method is not only more accurate (less error), it also holds in more cases. 
				%This is expected to improve accuracy by about 1-5\% depending on the fighters (remember that the benefit of this scales over periods of weeks \& months!).
				% For max melee, this saves 11 hours!

				\begin{figure}
					\centering
					\begin{subfigure}{.5\textwidth}
						\centering
						\includegraphics[width=\linewidth]{img/h2k_h2.png}
						\caption{Turns to Kill}
						% \label{fig:sub1}
					\end{subfigure}%
					\begin{subfigure}{.5\textwidth}
						\centering
						\includegraphics[width=\linewidth]{img/error.png}
						\caption{Error from Simulation}
						% \label{fig:sub2}
					\end{subfigure}
					\caption{
						A comparison between different models. The crude model does not consider the effects of overkill. The recursive model is that described in Eq.~\ref{eq:recursive_h} which best accounts for overkill. The Bitt-Nuke model averages the effect of overkill and attempt to handle it. Finally the simulation model is calculated by simulating many fights and averaging the results, within the standard error this is the true solution. On the left, the expected turns to kill (specifically number of successful hits). All three models \textit{appear} quite similar, however this is an artifact of scale. On the right, the percent relative error with respect to the simulations are shown. The noise is evident and occurs due to the difficulty of efficiently simulating the required number of fights (which justifies attempting to get analytic solutions!). The peak error is the region in which overkill is expected to occur. The average error of the recursive method is 4.94 with a variance of 22.6, while the Bitt-Nuke method has an average of 10.57 and a variance of 302.7!
					}\label{fig:comparison}
				\end{figure}

		\subsection{Experience and Damage Per Second}
			We saw that by inverting the damage per attack equation, Eq.~(\ref{eq:recursive_h}), we could determine the average number of successful attacks required to kill an opponent based on the max hit and starting health. To extend this to number of \textit{total} attacks we have to introduce accuracy, $a\in[0, 1]$. For the health per turn, $h(n)$, we simply note that $h(n)\to h(na)$ will appropriately reduce the number of ``effective turns''. Similarly, for turns to kill, $h^{-1}(1)=n\to n/a$ appropriately extends the number of turns expected. So multiplying and dividing easily accounts for accuracy.

			This can further be extended to time to kill by considering the time it takes for each attack. Let $s$ be the \textcolor{red}{attack speed (in attacks per second)}, then $n/(as)$ is the required time to kill an opponent. While the health at a given time, $t$ is $h(tas)$. This is a good time to note that the error shown in Fig.~(\ref{fig:comparison}) is unchanged since these multiplicative factors cancel out in the relative error calculation.

			Experience is calculated as a multiple, $e$ of the damage done. So if the opponent has $h_0$ health, and they are killed in $n/(as)$ seconds, then the experience per second is,
			\begin{equation}
				\boxed{E=eash_0/n}
			\end{equation}
			noting that $n$ is also a function of $h_0$, so $E$ does \emph{not} increase linearly with $h_0$. For most opponents, $e=4$ however there are \href{https://twitter.com/BitterkoekjeRS/status/803960032178110468}{exceptions}.

	\section{Nightmare Zone}
		We can now attempt to extend this into an useful application. For practical purposes, the Nightmare Zone (NMZ) is a combat training ground minigame that offers a low intensity, but efficient method of training combat skills. The player enters an arena with several bosses they have previously fought in the main game. At any given time, four (randomly chosen - with replacement) are in combat with the player. Before beginning, the player can decide a minimum of five bosses they would like to re-fight.

		\begin{figure}
			\includegraphics[width=\linewidth]{img/NMZ.png}
			\caption{A player (bottom-right) fighting against four bosses in the NMZ. Three of the bosses at this time happened to be the same, however each boss is expected to occur with equal probability.}
			\label{fig:nmz}
		\end{figure}

		This can be seen as a first a check, and second an optimization problem (to maximize experience). At this point we have calculated the experience per hour in terms of: accuracy, max hit, initial opponent health, and attack speed. The accuracy and max hit are involved yet straightforward calculations, while the other parameters are generally in a database. We have only made two assumptions so far, no health regeneration, and constant combat, along with 1 approximation in the turns to kill formula. \textcolor{red}{1 health is regenerated every minute the opponent is under their maximum health. [Pretty sure I've seen exceptions]} Thus, kills under on minute shouldn't be affected by this, while kills on the order of a few minutes only have a very small influence (since the duration of the fight typically implies high health). The lower the initial health of the opponent, the lower the impact of health regeneration.

		\subsection{Experimental Considerations}
			The health regeneration has a small effect of increasing damage per second by extending the non-overkill region and increasing the damage cap in the overkill region). Calculations are performed assuming continuous combat but due to random spawning, they may line up in a way that delays combat. Additionally, larger opponents would increase the probability of delay. Maintaining the player's own health requires some sort of consumption which may introduce delays. Finally, the bosses may spawn in unequal proportions (on average this should wash away, but may either increase or decrease the experience rates). These effects are summarized in Table.~\ref{table:considerations}.
			\begin{table}[]
				\centering
				\begin{tabular}{l|llll}
					\textbf{Property} & Regeneration                  & Intermittent Combat               & Sustainability & Equal Counts\\\toprule
					Impact          & \cellcolor[HTML]{34FF34}Higher & \cellcolor[HTML]{FD6864}Lower & \cellcolor[HTML]{FD6864}Lower& Random\\
					Multiplicative  & \cellcolor[HTML]{FD6864}No     & \cellcolor[HTML]{34FF34}Yes   & \cellcolor[HTML]{34FF34}Yes& \cellcolor[HTML]{34FF34}Yes  \\
				\end{tabular}
				\begin{tabular}{l}  % Used for Spacing
					\phantom{.} \\
				\end{tabular}

				\begin{tabular}{l|ll}
					\textbf{Method} & Overkill Consideration                     & Experience Prediction\\\toprule
					Crude           & Over Estimate    & Loose Lower Bound   \\
					Recursive        & Approximate    & Upper Bound    \\
					Simulation       & Approximate    & Upper Bound    \\
					Bitter           & Over Estimate   & Loose Lower Bound   \\\bottomrule
				\end{tabular}

				\caption{The top table shows the effect on experience rates when certain factors are properly considered.  Multiplicative factors means that that the ratio between two different rates are independent of these quantities, non-multiplicative factors appear inside the particular method which in general would not cancel. The bottom table relates how overkill is considered to the over/under prediction of experience rates. The properties with the largest influence decrease the experience rate. So the methods which well-approximate overkill are upper bounds. Those that over estimate it are lose lower bounds since otherwise they would be upper bounds so this additional decrease may or may not put it below the true expectation.}\label{table:considerations}
			\end{table}

		\subsection{Validation}
			To increase the probability that the player will remain in combat, only opponents who occupy a single tile will be used (that way more can stack up on the player, and they are more likely to retaliate against someone). For the sake of accuracy and reducing human error, no prayers, or special attack will be used. Additionally, tank gear, and absorption potions will be used to minimize the influence of sustaining the player's health. \href{https://runelite.net/}{Runelite}'s built-in experience rate tracker will be used to collect data.
			% 1x1 opponents
			\begin{figure}[H]
				\includegraphics[width=\linewidth]{img/Details.png}
				\caption{
					The main setup used for validation. Due to the nature of testing, some health, strength, and combat levels were gained, but were properly taken into account.
				}\label{fig:setup}
			\end{figure}

			\subsubsection{Time-Dependent Boosts}
				There are several time-dependent boosts in the game, most notably potions. Additionally, Dharok is a set of equipment which provides increased damage based on the health missing from the player. Since health recovers at a rate of one health per minute, and the boosted level from potions decreases one level per minute, these introduce time-dependent experience rates. Thankfully, the treatment is relatively simple. Let $a = a(t)$, and $M = M(t)$. At each boosted state, we can calculate the expected experience rate, and average over the boosted states:
				\begin{align}
					\boxed{\langle E \rangle = \frac{1}{N}\sum_{i=0}^{N} E(a(t_i), M(t_i))}
				\end{align}
				For example, if the player re-drinks a potion after $N=10$ levels have dropped, then the above determines the average experience. Things are a little bit more complex when both potions and Dharok are used since the timings might not line up, but for large times the detail should get averaged out.
			\subsubsection{Comparisons}
			\begin{tabularx}{\textwidth}{X|XXXXXX|}
				\textbf{Settings} & \textbf{Crude} & \textbf{Recursive} & \textbf{Simulation} & \textbf{Bitt-Nuke} & \textbf{GamePlay}\\\hline\hline\\
				\noindent\parbox[c]{1.5\hsize}{Easy\\No Potions\\$M\in[26]$\\8.36h} &
					66.9 $+$\textcolor{red}{15.19\%} &
					59.1 $+$\textcolor{red}{1.83\%} &
					58.5 $+$\textcolor{green}{0.78\%} &
					56.7 $-$\textcolor{red}{2.42\%} &
					58.1$\pm$0.6 [1.0\%]\\\\\hline\\

				\noindent\parbox[c]{1.5\hsize}{Hard\\No Potions\\$M\in[27]$\\8.19h} &
					68.7 $+$\textcolor{red}{6.52\%} &
					65.6 $+$\textcolor{red}{1.71\%} &
					65.5 $+$\textcolor{red}{1.49\%} &
					65.0 $+$\textcolor{red}{0.75\%} &
					64.5$\pm$0.4 [0.7\%]\\\\\hline\\

				\noindent\parbox[c]{1.5\hsize}{Easy\\Potions\\$M\in[27 .. 32]$\\6.84h} &
					79.8 $+$\textcolor{red}{18.16\%} &
					68.6 $+$\textcolor{red}{1.62\%} &
					68.3 $+$\textcolor{green}{1.21\%} &
					65.7 $-$\textcolor{red}{2.69\%} &
					67.5$\pm$1.0 [1.5\%]\\\\\hline\\

				\noindent\parbox[c]{1.5\hsize}{Hard\\Potions\\$M\in[27 .. 32]$\\6.81h} &
					79.6 $+$\textcolor{red}{6.25\%} &
					75.3 $+$\textcolor{green}{0.55\%} &
					75.2 $+$\textcolor{green}{0.45\%} &
					74.7 $-$\textcolor{green}{0.23\%} &
					74.9$\pm$0.9 [1.2\%]\\\\\hline\\

				\caption{Experience per hour predictions from different methods. Potions and Easy or Hard bosses which correspond to the boss difficulty (which only increases health and offensive capability) are varied. Each method reports two values, the xp/h [in kilo-xp] and the signed percent difference from the game play. Green coloring indicates there is agreement within error, red is used otherwise. The bracketed quantities are the relative error of the reported rate. Max hits are given as a range when potions are used. Data collection periods are also given in hours.}
			\end{tabularx}
			Since the largest (still small) source of errors in all models (constant combat, and health sustaining (absorptions potions)) negatively impact experience rates, we expect the models to be tight upper bounds on the actual gameplay experience. However, it's possible that the bosses don't spawn in equal amounts, which may bias the results in either direction (Runelite doesn't properly record kill counts to check this). For no potions, only the max hit matters, but for potions, the strength level also determines what the boost range. To prevent needing to account for this, when potions are used, runs are only carried out for a single strength level. For no potions, as long as the max hit is unchanged any strength level can be used.

			Bitt-Nuke over-considers low end which lowers estimate, but it can't be known if this lowering beats the unaccounted for non-constant combat. Which may explain why it was occasionally under-estimated results, while the Recursive method was always expected to be a upper-bound. This means that with additional corrections, the Recursive model will perform better than Bitt-Nuke, although as reported this seems effect isn't strong.

		\subsection{Optimization}
			In the NMZ, we can consider the player's opponents, and equipment as parameters to an optimization problem. This could also consider equipment cost. 

	\section{Improvements}
		Health regeneration. Analytic solution? Constant Combat (acts as reduced weapon speed so multiplicative). Health Sustainability. The last two shouldn't impact rankings since they are multiplicative and independent of the calculation method. Based on this, we can say that exact rankings is more important than exact approximations for practical purposes. Is the treatment $h=1$ for a kill valid for all methods? Since crude and Bitterkoekje can get to 0? I've seen (enemy) hp go up in under a minute. There must be a global timer, not just every 60s after you drop below max health.

	\section{Conclusion}
		We summarized the combat mechanics behind effective levels, accuracy, and maximum hits. We performed detailed calculations to determine piecewise average damage, based on whether overkill was present. In contrast to the Bitt-Nuke model, we maintain this piecewise relation and evaluate an recursive scheme to determine a more accurate form for the average damage. An analytic approximation was used to handle non-integer turns to kill an opponent, which can ultimately be used to calculate experience per hour. We discuss the effects which are not considered like health regeneration, and constant combat. Finally, experience per hour models are compared. The Recursive model is the best model due to its accuracy, and since it satisfies the expected upper bound property. Future work may look into forming an optimization problem.














		\newpage
		\appendix
		\titleformat{\section}[display]{\normalfont\Large\bfseries}{\appendixname\enspace\thesection}{.5em}{}
		\section{Average Damage}

			The average damage described in Section \ref{sec:average_damage} can be expanded to give,
			\begin{align}
				\langle D \rangle_\text{overall} &= \frac{1}{h_0}\left(
					\sum_{n=M+1}^{h_{0}}\frac{M}{2} +
					\sum_{n=1}^{y} \frac{n}{2}\left(2 - \frac{n + 1}{M+1}\right)
				\right) \\
				&= \frac{1}{h_0}\left(
					\frac{M}{2}(h_0-y) +
					\sum_{n=1}^{y}n - \frac{1}{2}\sum_{n=1}^yn\frac{n + 1}{M+1}
				\right) \\
				&= \frac{1}{2h_0}\left(
					Mh_0-My + y(y+1)
					 - \frac{1}{2({M+1})}\sum_{n=1}^y(n^2 + n)
				\right) \\
				&= \frac{1}{2h_0}\left(
					Mh_0-My + y(y+1) - \frac{y(y+1)}{2({M+1})}
					 - \frac{y(n+1)(2y+1)}{6({M+1})}
				\right) \\
				&= \frac{1}{2h_0({M+1})}\left(
					M^{2}h_{0}-M^{2}y+My^{2}+yM+Mh_{0}-My - \frac{y^3-y}{3}
				\right) \\
				&= \frac{y(y+1)}{h_0({M+1})}\left(
					\frac{M(M+1)h_{0}}{2y(y+1)}+\frac{(y-M)M}{2(y+1)} - \frac{y-1}{6}
				\right) \\
				&= \frac{y(y+1)}{h_0({M+1})}\left(
					\frac{M(M+1)h_{0}}{2y(y+1)}+\frac{(y-M)M}{2(y+1)} +\frac{y+1}{2} -\frac{1}{3}(2y+1)
				\right)
				\label{eq:app-average-damage-original}
			\end{align}
			where $y=\min(M, h_0)$. In the second line, we used:
			\begin{align}
				\sum_{a+1}^b1&=\begin{cases}
						b-a&\text{ if } b>a\\
						0 &\text{ else }
					\end{cases}\\
					&=b-\begin{cases}
						a &\text{ if } b>a\\
						0 &\text{ else }
					\end{cases}\\
					&=b-\min(a, b)
			\end{align}
			To finish, let's focus on,
			\begin{align}
				 &\frac{M(M+1)h_{0}}{2y(y+1)}+\frac{(y-M)M}{2(y+1)} +\frac{y+1}{2} \\
				=&\frac{1}{2y(y+1)}\Big[ M(M+1)h_{0}+y(y-M)M +y(y+1)^2 \Big]\\
				=&\frac{1}{2y(y+1)}\Big[ M^2h_{0}+Mh_0+My^2-M^2y +y^3+2y^2+y \Big].\label{eq:app-average-damage-bracket}
			\end{align}
			This is a hard equation to simplify since the $M$'s and $h_0$'s are implicitly embedded in the $y$'s, but if you play with it long enough you can ``discover'' a way to simplify it - a form \textit{power reduction} that relies on getting rid of as many $y$'s as possible.

			\subsection{Power Reduction}
				I'd like to preface the next part by saying the final result can easily be determined by plugging in $m$ as the $\min$, and $h_0$ as the $\min$ and combining the result. In this instance it works out nicely, but we will focus on general machinery to solve these problems assuming the solution was not so nice. Our goal here is to pull the $m$'s and $h_0$'s out of $y$. To do this, let's see if there is a way to construct $y^2$ from the other variables, specifically only using $y^1$. We know that if $M < h_0$, we need a term like $M^2$, and in the opposite case, we need a term like $h_0^2$,
				\begin{align}
					y^2 \sim M^2 \text{ or } h_0^2.
				\end{align}
				Based on this, we should be able to use $\min$ to switch between these two. So if we write the first term using $y$, we'd have something like $My$, which is true when $M$ is the minimum. If it isn't the minimum, there should be a second term which cancels the now $Mh_0$ term plus the required $h_0^2$ term:
				\begin{align}
					y^2 = My + h_0(y - M)\,\,\,\,\,(!)
				\end{align}
				Using the same logic, we can inductively deduce,
				\begin{align}
					\boxed{y^{n+1} = My^n + h_0^n(y - M) = My^n + h_0^ny - Mh_0^n.}
				\end{align}
				(and as an identity for the math people, with $\gamma = \min(a, b)$):
				\begin{align}
					\boxed{\gamma^{n+1} = a\gamma^n + b^n(\gamma - a) = a\gamma^n + b^n\gamma - ab^n}
				\end{align}
				In fact, this holds for $\max$ as well, or any \emph{similar} piece-wise function.
				Writing this as a recursive sequence by letting $g(n)=\gamma^n$ yields,
				\begin{align}
					g(n+1) = ag(n) + b^n(g(1) - a),
				\end{align}
				Under the initial condition $g(1)=\gamma$, \href{https://www.wolframalpha.com/input/?i=g%28n%2B1%29%3Da*g%28n%29%2Bb%5En%28C-a%29}{WolframAlpha} gives the general solution as,
				\begin{align}
					g(n) = a^n + (\gamma - a)\frac{a^n - b^n}{a - b} \\
					\boxed{g(n) = a^n + (\gamma - a)\sum_{i=0}^{n-1} a^{n-i-1}b^j,}
				\end{align}
				where the second line uses the difference of powers formula. This could have been solved by hand, but we've had enough fun with recursion in the other sections! This yields,
				\begin{align}
					g(1) &= \gamma\\
					g(2) &= a^2 + (\gamma - a)(a + b) \\
						&= a^2 + a\gamma - a^2  + b\gamma - ab \\
						&= a\gamma + b(\gamma - a) \\
					g(3) &= a^3 + (\gamma - a)\frac{a^3 - b^3}{a - b} \\
						&= a^3 + (\gamma - a)(a^2 + ab + b^2) \\
						&= a^3 + \gamma a^2 + \gamma ab + \gamma b^2 - a^3 - a^2b - ab^2 \\
						&= \gamma a^2 + \gamma ab + \gamma b^2 - a^2b - ab^2.
				\end{align}
				These agree with the original iterative equation. Okay, so this is a bit overkill since at most $y^3$ appears, so having general powers isn't too helpful. Nonetheless, we can now reduce the powers of $y$ in the original equation, and see how that simplifies things.
			\subsection{Simplifying}
				We can now reduce the bracketed term in Eq.~\ref{eq:app-average-damage-bracket}:
				\begin{align}
				 	&\phantom{=}M^2h_0+Mh_0+My^2                   -M^2y + y^3                                    +2y^2+y \\
				 	&=M^{2}h_{0}+Mh_{0}+M^{2}y+h_{0}yM-h_{0}M^{2}-M^{2}y+yM^{2}+yMh_{0}+yh_{0}^{2}+\\
				 		&\phantom{=========} -M^{2}h_{0}-h_{0}^{2}M+2My+2h_{0}y-2h_{0}M+y\\
				 	&=\left(-M^{2}y+yM^{2}+M^{2}y+yMh_{0}+yh_{0}^{2}+2My+2h_{0}y+y+h_{0}yM\right)+\\
				 		&\phantom{=========} \left(M^{2}h_{0}+Mh_{0}-h_{0}M^{2}+-M^{2}h_{0}-h_{0}^{2}M-2h_{0}M\right)\\
				 	&=\left(2My+2h_{0}y+y+2yMh_{0}+M^{2}y+yh_{0}^{2}\right)+\left(-M^{2}h_{0}-h_{0}^{2}M-h_{0}M\right)
				\end{align}
				Having eliminated the ``hidden'' variables, let's try to re-group into powers of $y$:
				\begin{align}
				 	&=y^{2}+\left(My+h_{0}y+y+2yMh_{0}+M^{2}y+yh_{0}^{2}\right)+\left(-M^{2}h_{0}-h_{0}^{2}M\right)\\
				 	&=2y^{2}+y+2yMh_{0}+M^{2}y+yh_{0}^{2}+-M^{2}h_{0}-h_{0}^{2}M+Mh_{0}\\
				 	&=y^{2}M+y+y^{2}+y^{2}h_{0}+y^{2}+Mh_{0}\\
				 	&=y\left(yM+yh_{0}+y+M+h_{0}+1\right)\\
				 	&=y\left(y+1\right)\left(M+h_{0}+1\right)
				\end{align}
				Putting this into the corresponding term in Eq.~\ref{eq:app-average-damage-original} gives
				\begin{align}
					\frac{1}{2y(y+1)}y(y+1)\left(M+h_{0}+1\right) = \frac{1}{2}\left(M+h_{0}+1\right)
				\end{align}
				and so finally we arrive at,
				\begin{align}
					\boxed{\langle D \rangle_\text{overall} = \frac{y(y+1)}{h_0({M+1})}\left[
						 \frac{1}{2}\left(M+h_{0} + 1\right) -\frac{1}{3}(2y+1)
					\right]}.
				\end{align}
		\newpage
		\section{Analytic Form Attempt}
			Here we will attempt to derive a more useful form of Eq.~\ref{eq:recur}. We will start with a slightly simpler relation,
			\begin{align}
				h_{n+1} &= h_n^2 + h_n.
			\end{align}
			We note that in general, this will be an expansion in terms of $h_0$,
			\begin{align}
				h_n = \sum_{i=1}^m a_i h_0^i.
			\end{align}
			Our goal then, is to determine the set of coefficients ${a_i}$. These coefficients implicitly depend on $n$. Our next iteration will look like,
			\begin{align}\label{eq:sum_n+1th_term}
				h_{n+1} = \left(\sum_{i=1}^m a_i h_0^i\right)^2 + \sum_{i=1}^m a_i h_0^i.
			\end{align}
			The squared term is actually very messy to deal with, requires the use of the Multinomial Theorem which (for the specific case $p=2$) states,
			\begin{align}
				\left(\sum_{i=1}^m x_i\right)^2 = 2\sum_{\{k_m\}=2} \prod_{t=1}^m \frac{x_t^{k_t}}{k_t!},
			\end{align}
			where $\{k_m\}=2$ denotes the sets of $m$ integers which add to two. For $m=4$ one example might look like: $(1, 0, 0, 1)$. For those of you familiar with this, these sets arise from integer partitioning, but we won't go over how these are generated, but just know there are algorithms for generating them. We will drop the $=2$ portion for brevity. Our form can be obtained with the transformation $x_i\to a_ih_0^i$,
			\begin{align}
				\left(\sum_{i=1}^m a_ih_0^i\right)^2 &= 2\sum_{\{k_m\}} \prod_{t=1}^m \frac{a_t^{k_t} h_0^{tk_t}}{k_t!} \\
				&= 2\sum_{\{k_m\}} \prod_{t=1}^m \frac{a_t^{k_t}}{k_t!} h_0^{\sum_{t=1}^m tk_t}.
			\end{align}
			Now let's return to the general n'th term (Eq.~\ref{eq:sum_n+1th_term}),
			\begin{align}
				h_n = 2\sum_{\{k_m\}} \prod_{t=1}^m \frac{a_t^{k_t}}{k_t!} h_0^{\sum_{t=1}^m tk_t} + \sum_{i=1}^m a_i h_0^i.
			\end{align}
			As-is, these cannot be combined. To handle this, we impose an ordering on $\{k_m\}$ so they they are given in increasing values of $\sum tk_t$, we will denote this as $\{k_m\}_i^{L}\uparrow$, where $L$ indicates the sum's value for the current set, and $i$ is the index of the current set. Now,
			\begin{align}
				h_n = 2\sum_{\{k_m\}_i^L\uparrow} \prod_{t=1}^m \frac{a_t^{k_t}}{k_t!} h_0^{L_m} + \sum_{i=1}^m a_i h_0^i.
			\end{align}
			Our only hope of combining these terms is to match up the powers. The good news is that now each term on the left, and right correspond to a single power.
			\begin{align}
				h_n = 2\sum_{\{k_m\}_i^L\uparrow} \left(\prod_{t=1}^m \frac{a_t^{k_t}}{k_t!} + a_i \right) h_0^{L_m},
			\end{align}
			Now, we should start from the bottom ($n=0$) and see if we can build up. For $n=0$, $h_{1}=h_0^2+h_0$. So the coefficients are $\{a\}^1 = (1, 1, 0, 0, 0, ...)$, where the zero padding accounts for the fact that the powers on the linear sum are less than the powers on the quadratic sum.

			We can read off the coefficient is we sort-of invert the sum notation. Let's instead sum across $i$.
			\begin{align}
				h_n = 2\sum_{i} \left(\prod_{\{k_t\}_i}^m \frac{a_t^{k_t}}{k_t!} + a_i \right) h_0^{L_i}.
			\end{align}
			Now the coefficient for the $L_i$'th power for the next iteration is
			\begin{align}
				a_{L_i} = 2\left(\prod_{\{k_t\}_i}^m \frac{a_t^{k_t}}{k_t!} + a_i \right).
			\end{align}
			This actually works out really well since the coefficients for our original problem simply get multiplied by $\gamma$! Let's make another simplification by letting $k_t$ be represented by a vector, $\vec k$ and constructing respective operations,
			\begin{align}
				a_{i, n+1} = 2 \frac{\boldsymbol{a}_n^\boldsymbol{k_i}}{\boldsymbol{k_i}!} + 2a_{i, n}.
			\end{align}
			Here a vector to the power of a vector is the product of the element-wise powers, and the factorial of a vector is the product of the element-wise factorials. This isn't very useful since it still requires an iterative scheme.
		% \end{appendices}


\end{document}
