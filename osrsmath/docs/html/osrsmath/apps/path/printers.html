<!doctype html>
<html lang="en">
<head>
<meta charset="utf-8">
<meta name="viewport" content="width=device-width, initial-scale=1, minimum-scale=1" />
<meta name="generator" content="pdoc 0.8.1" />
<title>osrsmath.apps.path.printers API documentation</title>
<meta name="description" content="" />
<link href='https://cdnjs.cloudflare.com/ajax/libs/normalize/8.0.0/normalize.min.css' rel='stylesheet'>
<link href='https://cdnjs.cloudflare.com/ajax/libs/10up-sanitize.css/8.0.0/sanitize.min.css' rel='stylesheet'>
<link href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/9.12.0/styles/github.min.css" rel="stylesheet">
<style>.flex{display:flex !important}body{line-height:1.5em}#content{padding:20px}#sidebar{padding:30px;overflow:hidden}#sidebar > *:last-child{margin-bottom:2cm}.http-server-breadcrumbs{font-size:130%;margin:0 0 15px 0}#footer{font-size:.75em;padding:5px 30px;border-top:1px solid #ddd;text-align:right}#footer p{margin:0 0 0 1em;display:inline-block}#footer p:last-child{margin-right:30px}h1,h2,h3,h4,h5{font-weight:300}h1{font-size:2.5em;line-height:1.1em}h2{font-size:1.75em;margin:1em 0 .50em 0}h3{font-size:1.4em;margin:25px 0 10px 0}h4{margin:0;font-size:105%}a{color:#058;text-decoration:none;transition:color .3s ease-in-out}a:hover{color:#e82}.title code{font-weight:bold}h2[id^="header-"]{margin-top:2em}.ident{color:#900}pre code{background:#f8f8f8;font-size:.8em;line-height:1.4em}code{background:#f2f2f1;padding:1px 4px;overflow-wrap:break-word}h1 code{background:transparent}pre{background:#f8f8f8;border:0;border-top:1px solid #ccc;border-bottom:1px solid #ccc;margin:1em 0;padding:1ex}#http-server-module-list{display:flex;flex-flow:column}#http-server-module-list div{display:flex}#http-server-module-list dt{min-width:10%}#http-server-module-list p{margin-top:0}.toc ul,#index{list-style-type:none;margin:0;padding:0}#index code{background:transparent}#index h3{border-bottom:1px solid #ddd}#index ul{padding:0}#index h4{margin-top:.6em;font-weight:bold}@media (min-width:200ex){#index .two-column{column-count:2}}@media (min-width:300ex){#index .two-column{column-count:3}}dl{margin-bottom:2em}dl dl:last-child{margin-bottom:4em}dd{margin:0 0 1em 3em}#header-classes + dl > dd{margin-bottom:3em}dd dd{margin-left:2em}dd p{margin:10px 0}.name{background:#eee;font-weight:bold;font-size:.85em;padding:5px 10px;display:inline-block;min-width:40%}.name:hover{background:#e0e0e0}.name > span:first-child{white-space:nowrap}.name.class > span:nth-child(2){margin-left:.4em}.inherited{color:#999;border-left:5px solid #eee;padding-left:1em}.inheritance em{font-style:normal;font-weight:bold}.desc h2{font-weight:400;font-size:1.25em}.desc h3{font-size:1em}.desc dt code{background:inherit}.source summary,.git-link-div{color:#666;text-align:right;font-weight:400;font-size:.8em;text-transform:uppercase}.source summary > *{white-space:nowrap;cursor:pointer}.git-link{color:inherit;margin-left:1em}.source pre{max-height:500px;overflow:auto;margin:0}.source pre code{font-size:12px;overflow:visible}.hlist{list-style:none}.hlist li{display:inline}.hlist li:after{content:',\2002'}.hlist li:last-child:after{content:none}.hlist .hlist{display:inline;padding-left:1em}img{max-width:100%}.admonition{padding:.1em .5em;margin-bottom:1em}.admonition-title{font-weight:bold}.admonition.note,.admonition.info,.admonition.important{background:#aef}.admonition.todo,.admonition.versionadded,.admonition.tip,.admonition.hint{background:#dfd}.admonition.warning,.admonition.versionchanged,.admonition.deprecated{background:#fd4}.admonition.error,.admonition.danger,.admonition.caution{background:lightpink}</style>
<style media="screen and (min-width: 700px)">@media screen and (min-width:700px){#sidebar{width:30%;height:100vh;overflow:auto;position:sticky;top:0}#content{width:70%;max-width:100ch;padding:3em 4em;border-left:1px solid #ddd}pre code{font-size:1em}.item .name{font-size:1em}main{display:flex;flex-direction:row-reverse;justify-content:flex-end}.toc ul ul,#index ul{padding-left:1.5em}.toc > ul > li{margin-top:.5em}}</style>
<style media="print">@media print{#sidebar h1{page-break-before:always}.source{display:none}}@media print{*{background:transparent !important;color:#000 !important;box-shadow:none !important;text-shadow:none !important}a[href]:after{content:" (" attr(href) ")";font-size:90%}a[href][title]:after{content:none}abbr[title]:after{content:" (" attr(title) ")"}.ir a:after,a[href^="javascript:"]:after,a[href^="#"]:after{content:""}pre,blockquote{border:1px solid #999;page-break-inside:avoid}thead{display:table-header-group}tr,img{page-break-inside:avoid}img{max-width:100% !important}@page{margin:0.5cm}p,h2,h3{orphans:3;widows:3}h1,h2,h3,h4,h5,h6{page-break-after:avoid}}</style>
<script async src='https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.5/latest.js?config=TeX-AMS_CHTML'></script>
</head>
<body>
<main>
<article id="content">
<header>
<h1 class="title">Module <code>osrsmath.apps.path.printers</code></h1>
</header>
<section id="section-intro">
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python"># from mpl_toolkits.mplot3d import Axes3D
import matplotlib.pyplot as plt
import matplotlib as mpl
import numpy as np
import os

class SchemePrinter:
        # Skill Cape Colors
        ATTACK_COLOR = (140, 42, 34)
        STRENGTH_COLOR = (13, 135, 88)
        DEFENCE_COLOR = (150, 165, 218)
        SKILL_VALUES = {&#39;a&#39;: 0, &#39;s&#39;: 1, &#39;d&#39;: 2}

        def __init__(self):
                self.schemes = []

        def training_scheme(self, path):
                leveled_skill = []
                prev_a, prev_s, prev_d = [int(x) for x in path.nodes[0].split(&#39;-&#39;)]
                for n, cost in zip(path.nodes[1:], path.costs):
                        a, s, d = [int(x) for x in n.split(&#39;-&#39;)]
                        print((prev_a, prev_s, prev_d), (a, s, d), cost)
                        if a &gt; prev_a:
                                leveled_skill.append(SchemePrinter.SKILL_VALUES[&#39;a&#39;])
                        elif s &gt; prev_s:
                                leveled_skill.append(SchemePrinter.SKILL_VALUES[&#39;s&#39;])
                        elif d &gt; prev_d:
                                leveled_skill.append(SchemePrinter.SKILL_VALUES[&#39;d&#39;])
                        else:
                                assert False, f&#34;A level was not gained: {path.nodes}&#34;
                        prev_a, prev_s, prev_d = a, s, d
                print(path.total_cost)
                return path.nodes[0], path.nodes[-1], leveled_skill

        def add_path(self, label, path):
                self.schemes.append((label, self.training_scheme(path)))

        def print(self, file_name=None, colors={&#39;a&#39;: ATTACK_COLOR, &#39;s&#39;: STRENGTH_COLOR, &#39;d&#39;: DEFENCE_COLOR}):
                assert self.schemes
                normalized_colors = {key: [v/255 for v in value] for key, value in colors.items()}

                fig, axes = plt.subplots(len(self.schemes), 1)
                if len(self.schemes) == 1:
                        axes = [axes]
                plt.xlabel(&#34;Levels Obtained&#34;)
                for axis, (name, (start, end, scheme)) in zip(axes, self.schemes):
                        axis.set_title(name, loc=&#39;center&#39;)
                        axis.set_yticklabels([])
                        axis.tick_params(axis=&#39;y&#39;, which=&#39;both&#39;, left=False, right=False, labelbottom=False)
                        axis.set_xticklabels([start, str(end)])
                        axis.set_xticks([0, len(scheme)])
                        used_colors = [rgb for skill, rgb in normalized_colors.items() if SchemePrinter.SKILL_VALUES[skill] in scheme]
                        axis.pcolor(np.array([scheme, ]), cmap=mpl.colors.ListedColormap(used_colors), edgecolors=&#39;black&#39;)

                plt.tight_layout()
                if file_name:
                        plt.savefig(f&#34;{file_name}.pdf&#34;)
                        os.system(f&#34;pdfcrop {file_name}.pdf&#34;)
                        os.rename(f&#34;{file_name}-crop.pdf&#34;, f&#34;{file_name}.pdf&#34;)
                plt.show()

class TreePrinter:
        DEFAULT_FILE_NAME = &#34;tree&#34;
        DEFAULT_GRID_THICKNESS = 1.8
        DEFAULT_GRID_COLOR = &#34;black&#34;
        DEFAULT_GRID_SPACING = (2.0, 1.0)
        COMPILATION_COMMAND = lambda file_path: f&#34;lualatex -shell-escape -interaction=batchmode {file_path}.tex&#34;  # -se improves memory usage
        # COMPILATION_COMMAND = lambda file_path: f&#34;lualatex -shell-escape  {file_path}.tex&#34;  # -se improves memory usage
        CLEAN_UP_COMMAND = lambda file_path: f&#34;rm {file_path}.tex {file_path}.aux {file_path}.log&#34;
        PREAMBLE = R&#34;&#34;&#34;
                \RequirePackage{luatex85}  % https://tex.stackexchange.com/questions/315025/lualatex-texlive-2016-standalone-undefined-control-sequence
                \documentclass[tikz, margin=0mm]{standalone}
                \usepackage{tkz-graph}
                \usetikzlibrary{calc}
                \renewcommand*{\EdgeLineWidth}{0.15pt}
        &#34;&#34;&#34;.replace(&#39;\t&#39;, &#39;&#39;).split(&#39;\n&#39;)[1:] + [&#39;\n&#39;]
        BEGIN_DOCUMENT = R&#34;&#34;&#34;
                \begin{document}
        &#34;&#34;&#34;.replace(&#39;\t&#39;, &#39;&#39;).split(&#39;\n&#39;)

        END_DOCUMENT = R&#34;&#34;&#34;
                \end{document}
        &#34;&#34;&#34;.replace(&#39;\t&#39;, &#39;&#39;).split(&#39;\n&#39;)

        TIKZ_START = R&#34;&#34;&#34;
                \begin{tikzpicture}
                \GraphInit[vstyle=Empty]
        &#34;&#34;&#34;.replace(&#39;\t&#39;, &#39;&#39;).split(&#39;\n&#39;)

        TIKZ_END = R&#34;&#34;&#34;
                \end{tikzpicture}
        &#34;&#34;&#34;.replace(&#39;\t&#39;, &#39;&#39;).split(&#39;\n&#39;)

        POSTAMBLE = R&#34;&#34;&#34;
        &#34;&#34;&#34;.replace(&#39;\t&#39;, &#39;&#39;).split(&#39;\n&#39;)

        def __init__(self, start, end):
                self.start = start
                self.end = end

                # Latex Contents
                self.vertices = []
                self.edges = []
                self.paths = []
                self.marks = []


        def _to_level(self, depth, index, defence):
                &#34;&#34;&#34; Converts the depth (row #) and vertex index (from left to right) to the corresponding attack and strength levels. &#34;&#34;&#34;
                sa, ss, _ = self.start
                return sa+depth-index-1, ss+index, defence

        def _to_vertex(self, attack, strength, defence):
                &#34;&#34;&#34; Converts an attack strength to the corresponding vertex representation. &#34;&#34;&#34;
                sa, ss, sd = self.start
                size = attack + strength - sa - ss + 1
                i = strength - ss
                return size, i, defence

        def format(self, depth, index, defence):
                &#34;&#34;&#34; Returns the string format using as the vertex identifier for a depth index pair. &#34;&#34;&#34;
                return f&#34;{depth}-{index}-{defence}&#34;

        def unformat(self, representation):
                &#34;&#34;&#34; Returns the string format using as the vertex identifier for a depth index pair. &#34;&#34;&#34;
                return [int(l) for l in representation.split(&#39;-&#39;)]

        def add_grid(self, cost_function=lambda p, c: (TreePrinter.DEFAULT_GRID_THICKNESS, TreePrinter.DEFAULT_GRID_COLOR),
                                 draw_dots=False, spacing=DEFAULT_GRID_SPACING, add_text=False):
                &#34;&#34;&#34; cost_function ([pa, ps, pd], [ca, cs, cd]) =&gt; (thickness, color),
                                where p, c is parent, child and a, s, d are attack, strength, and defence levels. &#34;&#34;&#34;
                sa, ss, sd = self.start
                ea, es, ed = self.end
                assert sd == ed, f&#34;Cannot print in 3 dimensions yet. Make start and end defence levels the same.&#34;

                for size in range(1, 2*(max(es, ea)-min(sa, ss))+1+1):
                        lines = []
                        edges = []
                        edges_levels = []
                        for i in range(size):
                                l, r, d = self._to_level(size, i, sd)
                                if l &gt; ea or r &gt; es: continue;  # This could be more efficient, but its not limiting.
                                x, y, text = (size / 2 - i )*spacing[0], -size*spacing[1], f&#34;${l}, {r}$&#34; if add_text else &#34;$$&#34;
                                self.vertices.append(Rf&#34;\Vertex[x={x}, y={y}, L={{{text}}}]{{{self.format(size, i, d)}}}&#34;)
                                if draw_dots:
                                        self.vertices.append(Rf&#34;\filldraw({(size / 2 - i )*spacing[0]}, {-size*spacing[1]}) circle[radius=2pt];&#34;)

                                if size &gt; 1:
                                        child = (size, i, d)
                                        parent = None
                                        if i &gt;= 1:
                                                parent = (size-1, i-1, d)
                                                thickness, color = cost_function(list( self._to_level(*parent) ), list( self._to_level(*child) ))
                                                self.edges.append(Rf&#34;\draw[-,line width={thickness:f}pt,color={color}] ({self.format(*child)}) --  ({self.format(*parent)});&#34;)
                                        if i &lt; size - 1:
                                                parent = (size-1, i, d)
                                                thickness, color = cost_function(list(self._to_level(*parent)), list(self._to_level(*child)))
                                                self.edges.append(Rf&#34;\draw[-,line width={thickness:f}pt,color={color}] ({self.format(*child)}) --  ({self.format(*parent)});&#34;)

        def mark_level(self, level, size=10, color=&#39;black&#39;):
                self.marks.append(Rf&#34;\filldraw[color={color}]({self.format(*self._to_vertex(*level))}) circle[radius={size}pt];&#34;)

        def add_paths(self, solution_paths, color=&#34;red&#34;, color_if_best=None):
                if color_if_best:
                        costs = [s.total_cost for s in solution_paths]
                        best_index = costs.index(min(costs))
                for i, solution_path in enumerate(solution_paths):
                        if color_if_best and i == best_index:
                                self.add_path(solution_path, color_if_best)
                        else:
                                self.add_path(solution_path, color)

        def add_path(self, solution_path, color=&#39;black&#39;, thickness=&#39;6&#39;, circle_start=True, circle_end=True):
                equipment = {}
                seen_equipment = set()
                path_latex = []
                for i, (node, (_, details)) in enumerate(zip(solution_path.nodes, solution_path.edges)):
                        diff = set(details[&#39;equipment&#39;].items()) ^ set(equipment.items())
                        new = [e for e in equipment.values() if e not in seen_equipment]
                        if new:
                                [seen_equipment.add(e) for e in new]
                                self.mark_level(self.unformat(node), color=&#39;green&#39;)
                        elif diff:
                                equipment = details[&#39;equipment&#39;]
                                self.mark_level(self.unformat(node), color=&#39;blue&#39;)
                        a = self.format(*self._to_vertex(*self.unformat(solution_path.nodes[i])))
                        b = self.format(*self._to_vertex(*self.unformat(solution_path.nodes[i+1])))

                        path_latex.append(Rf&#34;\draw[-,line width={thickness}pt,color={color}] ({a}) --  ({b});&#34;)
                        if circle_start and i == 0:
                                path_latex.append(Rf&#34;\filldraw({a}) circle[radius=10pt];&#34;)
                if circle_end:
                        path_latex.append(Rf&#34;\filldraw({b}) circle[radius=10pt];&#34;)
                self.paths.append(path_latex)

        def print(self, file_path=DEFAULT_FILE_NAME, clean=True, animate=False):
                assert self.edges, &#34;Must add a grid before printing&#34;
                with open(file_path+&#39;.tex&#39;, &#39;w&#39;) as f:
                        f.writelines(&#39;\n&#39;.join(self.PREAMBLE))
                        # if animate:
                                # f.write(R&#34;\usepackage{animate}&#34; + &#39;\n&#39;)
                        f.writelines(&#39;\n&#39;.join(self.BEGIN_DOCUMENT))
                        # if animate:
                                # f.write(R&#34;\pgfmathtruncatemacro\N{10}&#34; + &#39;\n&#39;)
                                # f.write(R&#34;\begin{animateinline}[controls,autoplay,loop]{2}&#34; + &#39;\n&#39;)
                        for i, path in enumerate(self.paths):
                                # if animate and i != 0:
                                        # f.write(R&#34;\newframe&#34; + &#39;\n&#39;)
                                f.writelines(&#39;\n&#39;.join(self.TIKZ_START) + &#39;\n&#39;)
                                f.writelines(&#39;\n&#39;.join(self.vertices) + &#39;\n&#39;)
                                f.writelines(&#39;\n&#39;.join(self.edges) + &#39;\n&#39;)
                                f.writelines(&#39;\n&#39;.join(path) + &#39;\n&#39;)
                                f.writelines(&#39;\n&#39;.join(self.marks) + &#39;\n&#39;)
                                f.writelines(&#39;\n&#39;.join(self.TIKZ_END) + &#39;\n&#39;)
                        # if animate:
                                # f.write(R&#34;\end{animateinline}&#34; + &#39;\n&#39;)
                        f.writelines(&#39;\n&#39;.join(self.END_DOCUMENT) + &#39;\n&#39;)
                        f.writelines(&#39;\n&#39;.join(self.POSTAMBLE) + &#39;\n&#39;)

                os.system(TreePrinter.COMPILATION_COMMAND(file_path))
                if animate:
                        os.system(f&#34;convert -density 300 -delay 20 -loop 0 -alpha remove {file_path}.pdf {file_path}.gif&#34;)
                if clean:
                        os.system(TreePrinter.CLEAN_UP_COMMAND(file_path))</code></pre>
</details>
</section>
<section>
</section>
<section>
</section>
<section>
</section>
<section>
<h2 class="section-title" id="header-classes">Classes</h2>
<dl>
<dt id="osrsmath.apps.path.printers.SchemePrinter"><code class="flex name class">
<span>class <span class="ident">SchemePrinter</span></span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class SchemePrinter:
        # Skill Cape Colors
        ATTACK_COLOR = (140, 42, 34)
        STRENGTH_COLOR = (13, 135, 88)
        DEFENCE_COLOR = (150, 165, 218)
        SKILL_VALUES = {&#39;a&#39;: 0, &#39;s&#39;: 1, &#39;d&#39;: 2}

        def __init__(self):
                self.schemes = []

        def training_scheme(self, path):
                leveled_skill = []
                prev_a, prev_s, prev_d = [int(x) for x in path.nodes[0].split(&#39;-&#39;)]
                for n, cost in zip(path.nodes[1:], path.costs):
                        a, s, d = [int(x) for x in n.split(&#39;-&#39;)]
                        print((prev_a, prev_s, prev_d), (a, s, d), cost)
                        if a &gt; prev_a:
                                leveled_skill.append(SchemePrinter.SKILL_VALUES[&#39;a&#39;])
                        elif s &gt; prev_s:
                                leveled_skill.append(SchemePrinter.SKILL_VALUES[&#39;s&#39;])
                        elif d &gt; prev_d:
                                leveled_skill.append(SchemePrinter.SKILL_VALUES[&#39;d&#39;])
                        else:
                                assert False, f&#34;A level was not gained: {path.nodes}&#34;
                        prev_a, prev_s, prev_d = a, s, d
                print(path.total_cost)
                return path.nodes[0], path.nodes[-1], leveled_skill

        def add_path(self, label, path):
                self.schemes.append((label, self.training_scheme(path)))

        def print(self, file_name=None, colors={&#39;a&#39;: ATTACK_COLOR, &#39;s&#39;: STRENGTH_COLOR, &#39;d&#39;: DEFENCE_COLOR}):
                assert self.schemes
                normalized_colors = {key: [v/255 for v in value] for key, value in colors.items()}

                fig, axes = plt.subplots(len(self.schemes), 1)
                if len(self.schemes) == 1:
                        axes = [axes]
                plt.xlabel(&#34;Levels Obtained&#34;)
                for axis, (name, (start, end, scheme)) in zip(axes, self.schemes):
                        axis.set_title(name, loc=&#39;center&#39;)
                        axis.set_yticklabels([])
                        axis.tick_params(axis=&#39;y&#39;, which=&#39;both&#39;, left=False, right=False, labelbottom=False)
                        axis.set_xticklabels([start, str(end)])
                        axis.set_xticks([0, len(scheme)])
                        used_colors = [rgb for skill, rgb in normalized_colors.items() if SchemePrinter.SKILL_VALUES[skill] in scheme]
                        axis.pcolor(np.array([scheme, ]), cmap=mpl.colors.ListedColormap(used_colors), edgecolors=&#39;black&#39;)

                plt.tight_layout()
                if file_name:
                        plt.savefig(f&#34;{file_name}.pdf&#34;)
                        os.system(f&#34;pdfcrop {file_name}.pdf&#34;)
                        os.rename(f&#34;{file_name}-crop.pdf&#34;, f&#34;{file_name}.pdf&#34;)
                plt.show()</code></pre>
</details>
<h3>Class variables</h3>
<dl>
<dt id="osrsmath.apps.path.printers.SchemePrinter.ATTACK_COLOR"><code class="name">var <span class="ident">ATTACK_COLOR</span></code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="osrsmath.apps.path.printers.SchemePrinter.DEFENCE_COLOR"><code class="name">var <span class="ident">DEFENCE_COLOR</span></code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="osrsmath.apps.path.printers.SchemePrinter.SKILL_VALUES"><code class="name">var <span class="ident">SKILL_VALUES</span></code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="osrsmath.apps.path.printers.SchemePrinter.STRENGTH_COLOR"><code class="name">var <span class="ident">STRENGTH_COLOR</span></code></dt>
<dd>
<div class="desc"></div>
</dd>
</dl>
<h3>Methods</h3>
<dl>
<dt id="osrsmath.apps.path.printers.SchemePrinter.add_path"><code class="name flex">
<span>def <span class="ident">add_path</span></span>(<span>self, label, path)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def add_path(self, label, path):
        self.schemes.append((label, self.training_scheme(path)))</code></pre>
</details>
</dd>
<dt id="osrsmath.apps.path.printers.SchemePrinter.print"><code class="name flex">
<span>def <span class="ident">print</span></span>(<span>self, file_name=None, colors={'a': (140, 42, 34), 's': (13, 135, 88), 'd': (150, 165, 218)})</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def print(self, file_name=None, colors={&#39;a&#39;: ATTACK_COLOR, &#39;s&#39;: STRENGTH_COLOR, &#39;d&#39;: DEFENCE_COLOR}):
        assert self.schemes
        normalized_colors = {key: [v/255 for v in value] for key, value in colors.items()}

        fig, axes = plt.subplots(len(self.schemes), 1)
        if len(self.schemes) == 1:
                axes = [axes]
        plt.xlabel(&#34;Levels Obtained&#34;)
        for axis, (name, (start, end, scheme)) in zip(axes, self.schemes):
                axis.set_title(name, loc=&#39;center&#39;)
                axis.set_yticklabels([])
                axis.tick_params(axis=&#39;y&#39;, which=&#39;both&#39;, left=False, right=False, labelbottom=False)
                axis.set_xticklabels([start, str(end)])
                axis.set_xticks([0, len(scheme)])
                used_colors = [rgb for skill, rgb in normalized_colors.items() if SchemePrinter.SKILL_VALUES[skill] in scheme]
                axis.pcolor(np.array([scheme, ]), cmap=mpl.colors.ListedColormap(used_colors), edgecolors=&#39;black&#39;)

        plt.tight_layout()
        if file_name:
                plt.savefig(f&#34;{file_name}.pdf&#34;)
                os.system(f&#34;pdfcrop {file_name}.pdf&#34;)
                os.rename(f&#34;{file_name}-crop.pdf&#34;, f&#34;{file_name}.pdf&#34;)
        plt.show()</code></pre>
</details>
</dd>
<dt id="osrsmath.apps.path.printers.SchemePrinter.training_scheme"><code class="name flex">
<span>def <span class="ident">training_scheme</span></span>(<span>self, path)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def training_scheme(self, path):
        leveled_skill = []
        prev_a, prev_s, prev_d = [int(x) for x in path.nodes[0].split(&#39;-&#39;)]
        for n, cost in zip(path.nodes[1:], path.costs):
                a, s, d = [int(x) for x in n.split(&#39;-&#39;)]
                print((prev_a, prev_s, prev_d), (a, s, d), cost)
                if a &gt; prev_a:
                        leveled_skill.append(SchemePrinter.SKILL_VALUES[&#39;a&#39;])
                elif s &gt; prev_s:
                        leveled_skill.append(SchemePrinter.SKILL_VALUES[&#39;s&#39;])
                elif d &gt; prev_d:
                        leveled_skill.append(SchemePrinter.SKILL_VALUES[&#39;d&#39;])
                else:
                        assert False, f&#34;A level was not gained: {path.nodes}&#34;
                prev_a, prev_s, prev_d = a, s, d
        print(path.total_cost)
        return path.nodes[0], path.nodes[-1], leveled_skill</code></pre>
</details>
</dd>
</dl>
</dd>
<dt id="osrsmath.apps.path.printers.TreePrinter"><code class="flex name class">
<span>class <span class="ident">TreePrinter</span></span>
<span>(</span><span>start, end)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class TreePrinter:
        DEFAULT_FILE_NAME = &#34;tree&#34;
        DEFAULT_GRID_THICKNESS = 1.8
        DEFAULT_GRID_COLOR = &#34;black&#34;
        DEFAULT_GRID_SPACING = (2.0, 1.0)
        COMPILATION_COMMAND = lambda file_path: f&#34;lualatex -shell-escape -interaction=batchmode {file_path}.tex&#34;  # -se improves memory usage
        # COMPILATION_COMMAND = lambda file_path: f&#34;lualatex -shell-escape  {file_path}.tex&#34;  # -se improves memory usage
        CLEAN_UP_COMMAND = lambda file_path: f&#34;rm {file_path}.tex {file_path}.aux {file_path}.log&#34;
        PREAMBLE = R&#34;&#34;&#34;
                \RequirePackage{luatex85}  % https://tex.stackexchange.com/questions/315025/lualatex-texlive-2016-standalone-undefined-control-sequence
                \documentclass[tikz, margin=0mm]{standalone}
                \usepackage{tkz-graph}
                \usetikzlibrary{calc}
                \renewcommand*{\EdgeLineWidth}{0.15pt}
        &#34;&#34;&#34;.replace(&#39;\t&#39;, &#39;&#39;).split(&#39;\n&#39;)[1:] + [&#39;\n&#39;]
        BEGIN_DOCUMENT = R&#34;&#34;&#34;
                \begin{document}
        &#34;&#34;&#34;.replace(&#39;\t&#39;, &#39;&#39;).split(&#39;\n&#39;)

        END_DOCUMENT = R&#34;&#34;&#34;
                \end{document}
        &#34;&#34;&#34;.replace(&#39;\t&#39;, &#39;&#39;).split(&#39;\n&#39;)

        TIKZ_START = R&#34;&#34;&#34;
                \begin{tikzpicture}
                \GraphInit[vstyle=Empty]
        &#34;&#34;&#34;.replace(&#39;\t&#39;, &#39;&#39;).split(&#39;\n&#39;)

        TIKZ_END = R&#34;&#34;&#34;
                \end{tikzpicture}
        &#34;&#34;&#34;.replace(&#39;\t&#39;, &#39;&#39;).split(&#39;\n&#39;)

        POSTAMBLE = R&#34;&#34;&#34;
        &#34;&#34;&#34;.replace(&#39;\t&#39;, &#39;&#39;).split(&#39;\n&#39;)

        def __init__(self, start, end):
                self.start = start
                self.end = end

                # Latex Contents
                self.vertices = []
                self.edges = []
                self.paths = []
                self.marks = []


        def _to_level(self, depth, index, defence):
                &#34;&#34;&#34; Converts the depth (row #) and vertex index (from left to right) to the corresponding attack and strength levels. &#34;&#34;&#34;
                sa, ss, _ = self.start
                return sa+depth-index-1, ss+index, defence

        def _to_vertex(self, attack, strength, defence):
                &#34;&#34;&#34; Converts an attack strength to the corresponding vertex representation. &#34;&#34;&#34;
                sa, ss, sd = self.start
                size = attack + strength - sa - ss + 1
                i = strength - ss
                return size, i, defence

        def format(self, depth, index, defence):
                &#34;&#34;&#34; Returns the string format using as the vertex identifier for a depth index pair. &#34;&#34;&#34;
                return f&#34;{depth}-{index}-{defence}&#34;

        def unformat(self, representation):
                &#34;&#34;&#34; Returns the string format using as the vertex identifier for a depth index pair. &#34;&#34;&#34;
                return [int(l) for l in representation.split(&#39;-&#39;)]

        def add_grid(self, cost_function=lambda p, c: (TreePrinter.DEFAULT_GRID_THICKNESS, TreePrinter.DEFAULT_GRID_COLOR),
                                 draw_dots=False, spacing=DEFAULT_GRID_SPACING, add_text=False):
                &#34;&#34;&#34; cost_function ([pa, ps, pd], [ca, cs, cd]) =&gt; (thickness, color),
                                where p, c is parent, child and a, s, d are attack, strength, and defence levels. &#34;&#34;&#34;
                sa, ss, sd = self.start
                ea, es, ed = self.end
                assert sd == ed, f&#34;Cannot print in 3 dimensions yet. Make start and end defence levels the same.&#34;

                for size in range(1, 2*(max(es, ea)-min(sa, ss))+1+1):
                        lines = []
                        edges = []
                        edges_levels = []
                        for i in range(size):
                                l, r, d = self._to_level(size, i, sd)
                                if l &gt; ea or r &gt; es: continue;  # This could be more efficient, but its not limiting.
                                x, y, text = (size / 2 - i )*spacing[0], -size*spacing[1], f&#34;${l}, {r}$&#34; if add_text else &#34;$$&#34;
                                self.vertices.append(Rf&#34;\Vertex[x={x}, y={y}, L={{{text}}}]{{{self.format(size, i, d)}}}&#34;)
                                if draw_dots:
                                        self.vertices.append(Rf&#34;\filldraw({(size / 2 - i )*spacing[0]}, {-size*spacing[1]}) circle[radius=2pt];&#34;)

                                if size &gt; 1:
                                        child = (size, i, d)
                                        parent = None
                                        if i &gt;= 1:
                                                parent = (size-1, i-1, d)
                                                thickness, color = cost_function(list( self._to_level(*parent) ), list( self._to_level(*child) ))
                                                self.edges.append(Rf&#34;\draw[-,line width={thickness:f}pt,color={color}] ({self.format(*child)}) --  ({self.format(*parent)});&#34;)
                                        if i &lt; size - 1:
                                                parent = (size-1, i, d)
                                                thickness, color = cost_function(list(self._to_level(*parent)), list(self._to_level(*child)))
                                                self.edges.append(Rf&#34;\draw[-,line width={thickness:f}pt,color={color}] ({self.format(*child)}) --  ({self.format(*parent)});&#34;)

        def mark_level(self, level, size=10, color=&#39;black&#39;):
                self.marks.append(Rf&#34;\filldraw[color={color}]({self.format(*self._to_vertex(*level))}) circle[radius={size}pt];&#34;)

        def add_paths(self, solution_paths, color=&#34;red&#34;, color_if_best=None):
                if color_if_best:
                        costs = [s.total_cost for s in solution_paths]
                        best_index = costs.index(min(costs))
                for i, solution_path in enumerate(solution_paths):
                        if color_if_best and i == best_index:
                                self.add_path(solution_path, color_if_best)
                        else:
                                self.add_path(solution_path, color)

        def add_path(self, solution_path, color=&#39;black&#39;, thickness=&#39;6&#39;, circle_start=True, circle_end=True):
                equipment = {}
                seen_equipment = set()
                path_latex = []
                for i, (node, (_, details)) in enumerate(zip(solution_path.nodes, solution_path.edges)):
                        diff = set(details[&#39;equipment&#39;].items()) ^ set(equipment.items())
                        new = [e for e in equipment.values() if e not in seen_equipment]
                        if new:
                                [seen_equipment.add(e) for e in new]
                                self.mark_level(self.unformat(node), color=&#39;green&#39;)
                        elif diff:
                                equipment = details[&#39;equipment&#39;]
                                self.mark_level(self.unformat(node), color=&#39;blue&#39;)
                        a = self.format(*self._to_vertex(*self.unformat(solution_path.nodes[i])))
                        b = self.format(*self._to_vertex(*self.unformat(solution_path.nodes[i+1])))

                        path_latex.append(Rf&#34;\draw[-,line width={thickness}pt,color={color}] ({a}) --  ({b});&#34;)
                        if circle_start and i == 0:
                                path_latex.append(Rf&#34;\filldraw({a}) circle[radius=10pt];&#34;)
                if circle_end:
                        path_latex.append(Rf&#34;\filldraw({b}) circle[radius=10pt];&#34;)
                self.paths.append(path_latex)

        def print(self, file_path=DEFAULT_FILE_NAME, clean=True, animate=False):
                assert self.edges, &#34;Must add a grid before printing&#34;
                with open(file_path+&#39;.tex&#39;, &#39;w&#39;) as f:
                        f.writelines(&#39;\n&#39;.join(self.PREAMBLE))
                        # if animate:
                                # f.write(R&#34;\usepackage{animate}&#34; + &#39;\n&#39;)
                        f.writelines(&#39;\n&#39;.join(self.BEGIN_DOCUMENT))
                        # if animate:
                                # f.write(R&#34;\pgfmathtruncatemacro\N{10}&#34; + &#39;\n&#39;)
                                # f.write(R&#34;\begin{animateinline}[controls,autoplay,loop]{2}&#34; + &#39;\n&#39;)
                        for i, path in enumerate(self.paths):
                                # if animate and i != 0:
                                        # f.write(R&#34;\newframe&#34; + &#39;\n&#39;)
                                f.writelines(&#39;\n&#39;.join(self.TIKZ_START) + &#39;\n&#39;)
                                f.writelines(&#39;\n&#39;.join(self.vertices) + &#39;\n&#39;)
                                f.writelines(&#39;\n&#39;.join(self.edges) + &#39;\n&#39;)
                                f.writelines(&#39;\n&#39;.join(path) + &#39;\n&#39;)
                                f.writelines(&#39;\n&#39;.join(self.marks) + &#39;\n&#39;)
                                f.writelines(&#39;\n&#39;.join(self.TIKZ_END) + &#39;\n&#39;)
                        # if animate:
                                # f.write(R&#34;\end{animateinline}&#34; + &#39;\n&#39;)
                        f.writelines(&#39;\n&#39;.join(self.END_DOCUMENT) + &#39;\n&#39;)
                        f.writelines(&#39;\n&#39;.join(self.POSTAMBLE) + &#39;\n&#39;)

                os.system(TreePrinter.COMPILATION_COMMAND(file_path))
                if animate:
                        os.system(f&#34;convert -density 300 -delay 20 -loop 0 -alpha remove {file_path}.pdf {file_path}.gif&#34;)
                if clean:
                        os.system(TreePrinter.CLEAN_UP_COMMAND(file_path))</code></pre>
</details>
<h3>Class variables</h3>
<dl>
<dt id="osrsmath.apps.path.printers.TreePrinter.BEGIN_DOCUMENT"><code class="name">var <span class="ident">BEGIN_DOCUMENT</span></code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="osrsmath.apps.path.printers.TreePrinter.DEFAULT_FILE_NAME"><code class="name">var <span class="ident">DEFAULT_FILE_NAME</span></code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="osrsmath.apps.path.printers.TreePrinter.DEFAULT_GRID_COLOR"><code class="name">var <span class="ident">DEFAULT_GRID_COLOR</span></code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="osrsmath.apps.path.printers.TreePrinter.DEFAULT_GRID_SPACING"><code class="name">var <span class="ident">DEFAULT_GRID_SPACING</span></code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="osrsmath.apps.path.printers.TreePrinter.DEFAULT_GRID_THICKNESS"><code class="name">var <span class="ident">DEFAULT_GRID_THICKNESS</span></code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="osrsmath.apps.path.printers.TreePrinter.END_DOCUMENT"><code class="name">var <span class="ident">END_DOCUMENT</span></code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="osrsmath.apps.path.printers.TreePrinter.POSTAMBLE"><code class="name">var <span class="ident">POSTAMBLE</span></code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="osrsmath.apps.path.printers.TreePrinter.PREAMBLE"><code class="name">var <span class="ident">PREAMBLE</span></code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="osrsmath.apps.path.printers.TreePrinter.TIKZ_END"><code class="name">var <span class="ident">TIKZ_END</span></code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="osrsmath.apps.path.printers.TreePrinter.TIKZ_START"><code class="name">var <span class="ident">TIKZ_START</span></code></dt>
<dd>
<div class="desc"></div>
</dd>
</dl>
<h3>Methods</h3>
<dl>
<dt id="osrsmath.apps.path.printers.TreePrinter.CLEAN_UP_COMMAND"><code class="name flex">
<span>def <span class="ident">CLEAN_UP_COMMAND</span></span>(<span>file_path)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">CLEAN_UP_COMMAND = lambda file_path: f&#34;rm {file_path}.tex {file_path}.aux {file_path}.log&#34;</code></pre>
</details>
</dd>
<dt id="osrsmath.apps.path.printers.TreePrinter.COMPILATION_COMMAND"><code class="name flex">
<span>def <span class="ident">COMPILATION_COMMAND</span></span>(<span>file_path)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">COMPILATION_COMMAND = lambda file_path: f&#34;lualatex -shell-escape -interaction=batchmode {file_path}.tex&#34;  # -se improves memory usage</code></pre>
</details>
</dd>
<dt id="osrsmath.apps.path.printers.TreePrinter.add_grid"><code class="name flex">
<span>def <span class="ident">add_grid</span></span>(<span>self, cost_function=&lt;function TreePrinter.&lt;lambda&gt;&gt;, draw_dots=False, spacing=(2.0, 1.0), add_text=False)</span>
</code></dt>
<dd>
<div class="desc"><p>cost_function ([pa, ps, pd], [ca, cs, cd]) =&gt; (thickness, color),
where p, c is parent, child and a, s, d are attack, strength, and defence levels.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def add_grid(self, cost_function=lambda p, c: (TreePrinter.DEFAULT_GRID_THICKNESS, TreePrinter.DEFAULT_GRID_COLOR),
                         draw_dots=False, spacing=DEFAULT_GRID_SPACING, add_text=False):
        &#34;&#34;&#34; cost_function ([pa, ps, pd], [ca, cs, cd]) =&gt; (thickness, color),
                        where p, c is parent, child and a, s, d are attack, strength, and defence levels. &#34;&#34;&#34;
        sa, ss, sd = self.start
        ea, es, ed = self.end
        assert sd == ed, f&#34;Cannot print in 3 dimensions yet. Make start and end defence levels the same.&#34;

        for size in range(1, 2*(max(es, ea)-min(sa, ss))+1+1):
                lines = []
                edges = []
                edges_levels = []
                for i in range(size):
                        l, r, d = self._to_level(size, i, sd)
                        if l &gt; ea or r &gt; es: continue;  # This could be more efficient, but its not limiting.
                        x, y, text = (size / 2 - i )*spacing[0], -size*spacing[1], f&#34;${l}, {r}$&#34; if add_text else &#34;$$&#34;
                        self.vertices.append(Rf&#34;\Vertex[x={x}, y={y}, L={{{text}}}]{{{self.format(size, i, d)}}}&#34;)
                        if draw_dots:
                                self.vertices.append(Rf&#34;\filldraw({(size / 2 - i )*spacing[0]}, {-size*spacing[1]}) circle[radius=2pt];&#34;)

                        if size &gt; 1:
                                child = (size, i, d)
                                parent = None
                                if i &gt;= 1:
                                        parent = (size-1, i-1, d)
                                        thickness, color = cost_function(list( self._to_level(*parent) ), list( self._to_level(*child) ))
                                        self.edges.append(Rf&#34;\draw[-,line width={thickness:f}pt,color={color}] ({self.format(*child)}) --  ({self.format(*parent)});&#34;)
                                if i &lt; size - 1:
                                        parent = (size-1, i, d)
                                        thickness, color = cost_function(list(self._to_level(*parent)), list(self._to_level(*child)))
                                        self.edges.append(Rf&#34;\draw[-,line width={thickness:f}pt,color={color}] ({self.format(*child)}) --  ({self.format(*parent)});&#34;)</code></pre>
</details>
</dd>
<dt id="osrsmath.apps.path.printers.TreePrinter.add_path"><code class="name flex">
<span>def <span class="ident">add_path</span></span>(<span>self, solution_path, color='black', thickness='6', circle_start=True, circle_end=True)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def add_path(self, solution_path, color=&#39;black&#39;, thickness=&#39;6&#39;, circle_start=True, circle_end=True):
        equipment = {}
        seen_equipment = set()
        path_latex = []
        for i, (node, (_, details)) in enumerate(zip(solution_path.nodes, solution_path.edges)):
                diff = set(details[&#39;equipment&#39;].items()) ^ set(equipment.items())
                new = [e for e in equipment.values() if e not in seen_equipment]
                if new:
                        [seen_equipment.add(e) for e in new]
                        self.mark_level(self.unformat(node), color=&#39;green&#39;)
                elif diff:
                        equipment = details[&#39;equipment&#39;]
                        self.mark_level(self.unformat(node), color=&#39;blue&#39;)
                a = self.format(*self._to_vertex(*self.unformat(solution_path.nodes[i])))
                b = self.format(*self._to_vertex(*self.unformat(solution_path.nodes[i+1])))

                path_latex.append(Rf&#34;\draw[-,line width={thickness}pt,color={color}] ({a}) --  ({b});&#34;)
                if circle_start and i == 0:
                        path_latex.append(Rf&#34;\filldraw({a}) circle[radius=10pt];&#34;)
        if circle_end:
                path_latex.append(Rf&#34;\filldraw({b}) circle[radius=10pt];&#34;)
        self.paths.append(path_latex)</code></pre>
</details>
</dd>
<dt id="osrsmath.apps.path.printers.TreePrinter.add_paths"><code class="name flex">
<span>def <span class="ident">add_paths</span></span>(<span>self, solution_paths, color='red', color_if_best=None)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def add_paths(self, solution_paths, color=&#34;red&#34;, color_if_best=None):
        if color_if_best:
                costs = [s.total_cost for s in solution_paths]
                best_index = costs.index(min(costs))
        for i, solution_path in enumerate(solution_paths):
                if color_if_best and i == best_index:
                        self.add_path(solution_path, color_if_best)
                else:
                        self.add_path(solution_path, color)</code></pre>
</details>
</dd>
<dt id="osrsmath.apps.path.printers.TreePrinter.format"><code class="name flex">
<span>def <span class="ident">format</span></span>(<span>self, depth, index, defence)</span>
</code></dt>
<dd>
<div class="desc"><p>Returns the string format using as the vertex identifier for a depth index pair.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def format(self, depth, index, defence):
        &#34;&#34;&#34; Returns the string format using as the vertex identifier for a depth index pair. &#34;&#34;&#34;
        return f&#34;{depth}-{index}-{defence}&#34;</code></pre>
</details>
</dd>
<dt id="osrsmath.apps.path.printers.TreePrinter.mark_level"><code class="name flex">
<span>def <span class="ident">mark_level</span></span>(<span>self, level, size=10, color='black')</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def mark_level(self, level, size=10, color=&#39;black&#39;):
        self.marks.append(Rf&#34;\filldraw[color={color}]({self.format(*self._to_vertex(*level))}) circle[radius={size}pt];&#34;)</code></pre>
</details>
</dd>
<dt id="osrsmath.apps.path.printers.TreePrinter.print"><code class="name flex">
<span>def <span class="ident">print</span></span>(<span>self, file_path='tree', clean=True, animate=False)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def print(self, file_path=DEFAULT_FILE_NAME, clean=True, animate=False):
        assert self.edges, &#34;Must add a grid before printing&#34;
        with open(file_path+&#39;.tex&#39;, &#39;w&#39;) as f:
                f.writelines(&#39;\n&#39;.join(self.PREAMBLE))
                # if animate:
                        # f.write(R&#34;\usepackage{animate}&#34; + &#39;\n&#39;)
                f.writelines(&#39;\n&#39;.join(self.BEGIN_DOCUMENT))
                # if animate:
                        # f.write(R&#34;\pgfmathtruncatemacro\N{10}&#34; + &#39;\n&#39;)
                        # f.write(R&#34;\begin{animateinline}[controls,autoplay,loop]{2}&#34; + &#39;\n&#39;)
                for i, path in enumerate(self.paths):
                        # if animate and i != 0:
                                # f.write(R&#34;\newframe&#34; + &#39;\n&#39;)
                        f.writelines(&#39;\n&#39;.join(self.TIKZ_START) + &#39;\n&#39;)
                        f.writelines(&#39;\n&#39;.join(self.vertices) + &#39;\n&#39;)
                        f.writelines(&#39;\n&#39;.join(self.edges) + &#39;\n&#39;)
                        f.writelines(&#39;\n&#39;.join(path) + &#39;\n&#39;)
                        f.writelines(&#39;\n&#39;.join(self.marks) + &#39;\n&#39;)
                        f.writelines(&#39;\n&#39;.join(self.TIKZ_END) + &#39;\n&#39;)
                # if animate:
                        # f.write(R&#34;\end{animateinline}&#34; + &#39;\n&#39;)
                f.writelines(&#39;\n&#39;.join(self.END_DOCUMENT) + &#39;\n&#39;)
                f.writelines(&#39;\n&#39;.join(self.POSTAMBLE) + &#39;\n&#39;)

        os.system(TreePrinter.COMPILATION_COMMAND(file_path))
        if animate:
                os.system(f&#34;convert -density 300 -delay 20 -loop 0 -alpha remove {file_path}.pdf {file_path}.gif&#34;)
        if clean:
                os.system(TreePrinter.CLEAN_UP_COMMAND(file_path))</code></pre>
</details>
</dd>
<dt id="osrsmath.apps.path.printers.TreePrinter.unformat"><code class="name flex">
<span>def <span class="ident">unformat</span></span>(<span>self, representation)</span>
</code></dt>
<dd>
<div class="desc"><p>Returns the string format using as the vertex identifier for a depth index pair.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def unformat(self, representation):
        &#34;&#34;&#34; Returns the string format using as the vertex identifier for a depth index pair. &#34;&#34;&#34;
        return [int(l) for l in representation.split(&#39;-&#39;)]</code></pre>
</details>
</dd>
</dl>
</dd>
</dl>
</section>
</article>
<nav id="sidebar">
<h1>Index</h1>
<div class="toc">
<ul></ul>
</div>
<ul id="index">
<li><h3>Super-module</h3>
<ul>
<li><code><a title="osrsmath.apps.path" href="index.html">osrsmath.apps.path</a></code></li>
</ul>
</li>
<li><h3><a href="#header-classes">Classes</a></h3>
<ul>
<li>
<h4><code><a title="osrsmath.apps.path.printers.SchemePrinter" href="#osrsmath.apps.path.printers.SchemePrinter">SchemePrinter</a></code></h4>
<ul class="two-column">
<li><code><a title="osrsmath.apps.path.printers.SchemePrinter.ATTACK_COLOR" href="#osrsmath.apps.path.printers.SchemePrinter.ATTACK_COLOR">ATTACK_COLOR</a></code></li>
<li><code><a title="osrsmath.apps.path.printers.SchemePrinter.DEFENCE_COLOR" href="#osrsmath.apps.path.printers.SchemePrinter.DEFENCE_COLOR">DEFENCE_COLOR</a></code></li>
<li><code><a title="osrsmath.apps.path.printers.SchemePrinter.SKILL_VALUES" href="#osrsmath.apps.path.printers.SchemePrinter.SKILL_VALUES">SKILL_VALUES</a></code></li>
<li><code><a title="osrsmath.apps.path.printers.SchemePrinter.STRENGTH_COLOR" href="#osrsmath.apps.path.printers.SchemePrinter.STRENGTH_COLOR">STRENGTH_COLOR</a></code></li>
<li><code><a title="osrsmath.apps.path.printers.SchemePrinter.add_path" href="#osrsmath.apps.path.printers.SchemePrinter.add_path">add_path</a></code></li>
<li><code><a title="osrsmath.apps.path.printers.SchemePrinter.print" href="#osrsmath.apps.path.printers.SchemePrinter.print">print</a></code></li>
<li><code><a title="osrsmath.apps.path.printers.SchemePrinter.training_scheme" href="#osrsmath.apps.path.printers.SchemePrinter.training_scheme">training_scheme</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="osrsmath.apps.path.printers.TreePrinter" href="#osrsmath.apps.path.printers.TreePrinter">TreePrinter</a></code></h4>
<ul class="">
<li><code><a title="osrsmath.apps.path.printers.TreePrinter.BEGIN_DOCUMENT" href="#osrsmath.apps.path.printers.TreePrinter.BEGIN_DOCUMENT">BEGIN_DOCUMENT</a></code></li>
<li><code><a title="osrsmath.apps.path.printers.TreePrinter.CLEAN_UP_COMMAND" href="#osrsmath.apps.path.printers.TreePrinter.CLEAN_UP_COMMAND">CLEAN_UP_COMMAND</a></code></li>
<li><code><a title="osrsmath.apps.path.printers.TreePrinter.COMPILATION_COMMAND" href="#osrsmath.apps.path.printers.TreePrinter.COMPILATION_COMMAND">COMPILATION_COMMAND</a></code></li>
<li><code><a title="osrsmath.apps.path.printers.TreePrinter.DEFAULT_FILE_NAME" href="#osrsmath.apps.path.printers.TreePrinter.DEFAULT_FILE_NAME">DEFAULT_FILE_NAME</a></code></li>
<li><code><a title="osrsmath.apps.path.printers.TreePrinter.DEFAULT_GRID_COLOR" href="#osrsmath.apps.path.printers.TreePrinter.DEFAULT_GRID_COLOR">DEFAULT_GRID_COLOR</a></code></li>
<li><code><a title="osrsmath.apps.path.printers.TreePrinter.DEFAULT_GRID_SPACING" href="#osrsmath.apps.path.printers.TreePrinter.DEFAULT_GRID_SPACING">DEFAULT_GRID_SPACING</a></code></li>
<li><code><a title="osrsmath.apps.path.printers.TreePrinter.DEFAULT_GRID_THICKNESS" href="#osrsmath.apps.path.printers.TreePrinter.DEFAULT_GRID_THICKNESS">DEFAULT_GRID_THICKNESS</a></code></li>
<li><code><a title="osrsmath.apps.path.printers.TreePrinter.END_DOCUMENT" href="#osrsmath.apps.path.printers.TreePrinter.END_DOCUMENT">END_DOCUMENT</a></code></li>
<li><code><a title="osrsmath.apps.path.printers.TreePrinter.POSTAMBLE" href="#osrsmath.apps.path.printers.TreePrinter.POSTAMBLE">POSTAMBLE</a></code></li>
<li><code><a title="osrsmath.apps.path.printers.TreePrinter.PREAMBLE" href="#osrsmath.apps.path.printers.TreePrinter.PREAMBLE">PREAMBLE</a></code></li>
<li><code><a title="osrsmath.apps.path.printers.TreePrinter.TIKZ_END" href="#osrsmath.apps.path.printers.TreePrinter.TIKZ_END">TIKZ_END</a></code></li>
<li><code><a title="osrsmath.apps.path.printers.TreePrinter.TIKZ_START" href="#osrsmath.apps.path.printers.TreePrinter.TIKZ_START">TIKZ_START</a></code></li>
<li><code><a title="osrsmath.apps.path.printers.TreePrinter.add_grid" href="#osrsmath.apps.path.printers.TreePrinter.add_grid">add_grid</a></code></li>
<li><code><a title="osrsmath.apps.path.printers.TreePrinter.add_path" href="#osrsmath.apps.path.printers.TreePrinter.add_path">add_path</a></code></li>
<li><code><a title="osrsmath.apps.path.printers.TreePrinter.add_paths" href="#osrsmath.apps.path.printers.TreePrinter.add_paths">add_paths</a></code></li>
<li><code><a title="osrsmath.apps.path.printers.TreePrinter.format" href="#osrsmath.apps.path.printers.TreePrinter.format">format</a></code></li>
<li><code><a title="osrsmath.apps.path.printers.TreePrinter.mark_level" href="#osrsmath.apps.path.printers.TreePrinter.mark_level">mark_level</a></code></li>
<li><code><a title="osrsmath.apps.path.printers.TreePrinter.print" href="#osrsmath.apps.path.printers.TreePrinter.print">print</a></code></li>
<li><code><a title="osrsmath.apps.path.printers.TreePrinter.unformat" href="#osrsmath.apps.path.printers.TreePrinter.unformat">unformat</a></code></li>
</ul>
</li>
</ul>
</li>
</ul>
</nav>
</main>
<footer id="footer">
<p>Generated by <a href="https://pdoc3.github.io/pdoc"><cite>pdoc</cite> 0.8.1</a>.</p>
</footer>
<script src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/9.12.0/highlight.min.js"></script>
<script>hljs.initHighlightingOnLoad()</script>
</body>
</html>